package aurick.opsec.mod.detection;

import aurick.opsec.mod.PrivacyLogger;

/**
 * ThreadLocal-based context tracking for translation exploit protection.
 * 
 * This allows us to detect when we're in an exploitable context (sign, anvil, book)
 * without expensive stack trace analysis. UI screen mixins set the context when
 * entering vulnerable screens, and protection mixins check it.
 * 
 * Performance: ThreadLocal.get() is ~0.01 microseconds (essentially free).
 */
public class ExploitContext {
    
    private static final ThreadLocal<PrivacyLogger.ExploitSource> currentContext = new ThreadLocal<>();
    
    private ExploitContext() {}
    
    /**
     * Enter an exploitable context. Called by UI screen mixins.
     * @param source The type of exploitable context (SIGN, ANVIL, BOOK)
     */
    public static void enterContext(PrivacyLogger.ExploitSource source) {
        currentContext.set(source);
    }
    
    /**
     * Exit the current context. Must be called when leaving the exploitable screen.
     */
    public static void exitContext() {
        currentContext.remove();
    }
    
    /**
     * Check if we're currently in an exploitable context.
     * @return true if in a sign/anvil/book screen, false otherwise
     */
    public static boolean isInExploitableContext() {
        return currentContext.get() != null;
    }
    
    /**
     * Get the current exploit source type.
     * @return The current context source, or UNKNOWN if not in a context
     */
    public static PrivacyLogger.ExploitSource getSource() {
        PrivacyLogger.ExploitSource source = currentContext.get();
        return source != null ? source : PrivacyLogger.ExploitSource.UNKNOWN;
    }
}

