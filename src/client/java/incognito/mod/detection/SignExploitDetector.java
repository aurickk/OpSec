package incognito.mod.detection;

import incognito.mod.Incognito;
import incognito.mod.util.KeybindDefaults;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.contents.KeybindContents;
import net.minecraft.network.chat.contents.TranslatableContents;

import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Advanced sign/anvil translation vulnerability detector.
 * 
 * The vulnerability works by:
 * 1. Server sends a sign/item with translation keys or keybind components
 * 2. Client resolves these to actual values (language, keybinds, mod presence)
 * 3. Client sends the resolved text back to the server
 * 
 * This leaks:
 * - Player's language/locale (via language.name, etc.)
 * - Keybind configurations (via key.*, category.*)
 * - Installed mods (via mod-specific translation keys like "modid.item.name")
 * - Client version info
 * 
 * Detection improvements:
 * - Comprehensive list of known mod translation key patterns
 * - Keybind detection for custom mod keybinds
 * - Language/locale probing detection
 * - Heuristic analysis for unknown patterns
 * 
 * @see <a href="https://wurst.wiki/sign_translation_vulnerability">Sign Translation Vulnerability</a>
 * @see <a href="https://github.com/NikOverflow/ExploitPreventer">ExploitPreventer</a>
 */
public class SignExploitDetector {
    
    private static boolean playerOpenedSign = false;
    private static long lastPlayerInteraction = 0;
    private static final long INTERACTION_TIMEOUT_MS = 500;
    
    // Translation key pattern - matches standard Minecraft translation key format
    private static final Pattern TRANSLATION_KEY_PATTERN = Pattern.compile(
        "^[a-z0-9_.-]+\\.[a-z0-9_.:-]+$",
        Pattern.CASE_INSENSITIVE
    );
    
    // Keybind key pattern
    private static final Pattern KEYBIND_PATTERN = Pattern.compile(
        "^key\\.[a-z0-9_.:-]+$",
        Pattern.CASE_INSENSITIVE
    );
    
    // Known language/locale probing keys
    private static final Set<String> LANGUAGE_PROBE_KEYS = Set.of(
        "language.name",
        "language.region",
        "language.code",
        "options.language",
        "narrator.button.language",
        "pack.language"
    );
    
    // Known keybind probing prefixes
    private static final Set<String> KEYBIND_PROBE_PREFIXES = Set.of(
        "key.",
        "category.",
        "key.keyboard.",
        "key.mouse.",
        "controls.",
        "key.categories."
    );
    
    // Known mod-specific translation key prefixes (popular mods)
    // These are mods that servers commonly try to detect
    private static final Set<String> KNOWN_MOD_PREFIXES = Set.of(
        // Cheat clients / utility mods
        "wurst.", "meteor.", "meteor-client.", "aristois.", "inertia.", "kami.", "kamiblue.",
        "lambda.", "rusherhack.", "future.", "impact.", "salhack.", "phobos.", "konas.",
        "liquidbounce.", "fdpclient.", "rise.", "novoline.", "exhibition.", "flux.",
        
        // Popular utility/QoL mods
        "xaero.", "xaeroworldmap.", "xaerominimap.", "journeymap.", "voxelmap.",
        "litematica.", "minihud.", "tweakeroo.", "itemscroller.", "malilib.",
        "freecam.", "replaymod.", "replay.", "baritone.", "schematica.",
        "betterf3.", "appleskin.", "hwyla.", "waila.", "wthit.", "jade.",
        "inventoryprofiles.", "inventoryhud.", "shulkerboxtooltip.",
        "notenoughcrashes.", "modmenu.", "fabricapi.", "fabric.",
        
        // Combat/PvP mods
        "totemcounter.", "crystaloptimizer.", "autocrystal.", "cpvp.",
        "crystalaura.", "combatclient.", "kohi.", "badlion.", "lunar.",
        
        // Fabric/Forge specific
        "fabric-api.", "fabric-screen-handler.", "fabric-networking.",
        "forge.", "neoforge.", "fml.", "forgemod.",
        
        // Voice chat mods
        "voicechat.", "plasmo_voice.", "mumble.", "simple_voice_chat.",
        
        // Other commonly detected mods
        "sodium.", "lithium.", "phosphor.", "starlight.", "iris.",
        "optifine.", "optifabric.", "lambdamap.", "lambdynamiclights.",
        "essential.", "feather.", "labymod.", "5zig."
    );
    
    // Vanilla translation key prefixes (these are safe/expected)
    private static final Set<String> VANILLA_PREFIXES = Set.of(
        "block.minecraft.", "item.minecraft.", "entity.minecraft.", "biome.minecraft.",
        "effect.minecraft.", "enchantment.minecraft.", "stat.minecraft.", "advancement.minecraft.",
        "container.", "commands.", "chat.", "death.", "deathScreen.", "title.", "menu.",
        "narrator.", "gui.", "multiplayer.", "selectWorld.", "createWorld.", "generator.",
        "gameMode.", "difficulty.", "spectatorMenu.", "resourcePack.", "lanServer.",
        "controls.", "soundCategory.", "options.", "disconnect.", "connect.",
        "attribute.minecraft.", "potion.minecraft.", "record.", "subtitles.",
        "tutorial.", "book.", "argument.", "parsing.", "pack.", "accessibility.",
        "telemetry.", "realms.", "mco.", "gamerule.", "structure_block.", "jigsaw_block.",
        "sign.", "filled_map.", "painting.", "trim_pattern.", "trim_material.",
        "upgrade.", "banner.", "sleep.", "block.", "item.", "entity."
    );
    
    private static final Map<String, String> LANGUAGE_VALUE_TO_KEY = Map.ofEntries(
        Map.entry("English", "language.name"),
        Map.entry("English (US)", "language.name"),
        Map.entry("English (UK)", "language.name"),
        Map.entry("United States", "language.region"),
        Map.entry("United Kingdom", "language.region"),
        Map.entry("en_us", "language.code"),
        Map.entry("en_gb", "language.code"),
        Map.entry("Deutsch", "language.name"),
        Map.entry("German", "language.name"),
        Map.entry("de_de", "language.code"),
        Map.entry("Français", "language.name"),
        Map.entry("French", "language.name"),
        Map.entry("fr_fr", "language.code"),
        Map.entry("Español", "language.name"),
        Map.entry("Spanish", "language.name"),
        Map.entry("es_es", "language.code"),
        Map.entry("Português", "language.name"),
        Map.entry("Portuguese", "language.name"),
        Map.entry("pt_br", "language.code"),
        Map.entry("Русский", "language.name"),
        Map.entry("Russian", "language.name"),
        Map.entry("ru_ru", "language.code"),
        Map.entry("中文", "language.name"),
        Map.entry("Chinese", "language.name"),
        Map.entry("zh_cn", "language.code"),
        Map.entry("日本語", "language.name"),
        Map.entry("Japanese", "language.name"),
        Map.entry("ja_jp", "language.code"),
        Map.entry("한국어", "language.name"),
        Map.entry("Korean", "language.name"),
        Map.entry("ko_kr", "language.code")
    );
    
    public record DetectionResult(
        DetectionType type,
        String key,
        String reason,
        int severity  // 1-5
    ) {}
    
    public enum DetectionType {
        NONE,
        LANGUAGE_PROBE,
        KEYBIND_PROBE,
        MOD_DETECTION,
        SUSPICIOUS_KEY,
        COMPONENT_TRANSLATABLE,
        COMPONENT_KEYBIND
    }
    
    /**
     * Mark that the player is interacting with a sign
     */
    public static void markPlayerInteraction() {
        playerOpenedSign = true;
        lastPlayerInteraction = System.currentTimeMillis();
    }
    
    /**
     * Check if the current sign opening was initiated by the player
     */
    public static boolean wasPlayerInitiated() {
        long now = System.currentTimeMillis();
        boolean valid = playerOpenedSign && (now - lastPlayerInteraction < INTERACTION_TIMEOUT_MS);
        
        // Reset after check
        playerOpenedSign = false;
        
        return valid;
    }
    
    /**
     * Comprehensive check if text contains exploitable content
     */
    public static boolean containsExploitableContent(String text) {
        if (text == null || text.isEmpty()) {
            return false;
        }
        
        DetectionResult result = analyzeText(text);
        return result.type != DetectionType.NONE;
    }
    
    /**
     * Analyze text for exploit patterns and return detailed result
     */
    public static DetectionResult analyzeText(String text) {
        if (text == null || text.isEmpty()) {
            return new DetectionResult(DetectionType.NONE, null, null, 0);
        }
        
        String trimmed = text.trim().toLowerCase();
        
        for (String probe : LANGUAGE_PROBE_KEYS) {
            if (trimmed.equals(probe) || trimmed.startsWith(probe + ".")) {
                return new DetectionResult(DetectionType.LANGUAGE_PROBE, text, "Language/locale probing key detected", 5);
            }
        }
        
        for (String prefix : KEYBIND_PROBE_PREFIXES) {
            if (trimmed.startsWith(prefix)) {
                return new DetectionResult(DetectionType.KEYBIND_PROBE, text, "Keybind probing key detected", 4);
            }
        }
        
        for (String modPrefix : KNOWN_MOD_PREFIXES) {
            if (trimmed.startsWith(modPrefix)) {
                return new DetectionResult(DetectionType.MOD_DETECTION, text, "Mod detection key for: " + modPrefix.replace(".", ""), 5);
            }
        }
        
        if (TRANSLATION_KEY_PATTERN.matcher(trimmed).matches()) {
            boolean isVanilla = false;
            for (String vanillaPrefix : VANILLA_PREFIXES) {
                if (trimmed.startsWith(vanillaPrefix)) {
                    isVanilla = true;
                    break;
                }
            }
            
            if (!isVanilla) {
                return new DetectionResult(DetectionType.SUSPICIOUS_KEY, text, "Non-vanilla translation key detected", 3);
            }
        }
        
        return new DetectionResult(DetectionType.NONE, null, null, 0);
    }
    
    public static boolean containsTranslatableContent(Component component) {
        if (component == null) {
            return false;
        }
        
        var contents = component.getContents();
        if (contents instanceof TranslatableContents translatable) {
            DetectionResult result = analyzeTranslationKey(translatable.getKey());
            if (result.type != DetectionType.NONE) {
                return true;
            }
        }
        
        if (contents instanceof KeybindContents) {
            return true;
        }
        
        for (Component sibling : component.getSiblings()) {
            if (containsTranslatableContent(sibling)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Analyze a translation key from a TranslatableContents
     */
    public static DetectionResult analyzeTranslationKey(String key) {
        if (key == null) {
            return new DetectionResult(DetectionType.NONE, null, null, 0);
        }
        
        String lowerKey = key.toLowerCase();
        
        // Check for language probing
        for (String probe : LANGUAGE_PROBE_KEYS) {
            if (lowerKey.equals(probe) || lowerKey.startsWith(probe + ".")) {
                return new DetectionResult(DetectionType.LANGUAGE_PROBE, key, "Language probe", 5);
            }
        }
        
        // Check for keybind probing
        for (String prefix : KEYBIND_PROBE_PREFIXES) {
            if (lowerKey.startsWith(prefix)) {
                return new DetectionResult(DetectionType.KEYBIND_PROBE, key, "Keybind probe", 4);
            }
        }
        
        // Check for known mod prefixes
        for (String modPrefix : KNOWN_MOD_PREFIXES) {
            if (lowerKey.startsWith(modPrefix)) {
                return new DetectionResult(DetectionType.MOD_DETECTION, key, 
                    "Mod detection: " + modPrefix.replace(".", ""), 5);
            }
        }
        
        // Check if it's a vanilla key (safe)
        for (String vanillaPrefix : VANILLA_PREFIXES) {
            if (lowerKey.startsWith(vanillaPrefix)) {
                return new DetectionResult(DetectionType.NONE, null, null, 0);
            }
        }
        
        // Unknown key - potentially suspicious
        if (TRANSLATION_KEY_PATTERN.matcher(lowerKey).matches()) {
            return new DetectionResult(DetectionType.SUSPICIOUS_KEY, key, "Unknown translation key", 2);
        }
        
        return new DetectionResult(DetectionType.NONE, null, null, 0);
    }
    
    /**
     * Analyze a keybind key from KeybindContents (e.g., "key.forward", "key.wurst.something")
     */
    public static DetectionResult analyzeKeybind(String key) {
        if (key == null) {
            return new DetectionResult(DetectionType.NONE, null, null, 0);
        }
        
        String lowerKey = key.toLowerCase();
        
        // Check for mod keybinds (non-vanilla)
        for (String modPrefix : KNOWN_MOD_PREFIXES) {
            if (lowerKey.startsWith(modPrefix)) {
                return new DetectionResult(DetectionType.MOD_DETECTION, key, 
                    "Mod keybind: " + modPrefix.replace(".", ""), 5);
            }
        }
        
        // Vanilla keybinds are still suspicious in exploit context
        // because they reveal user's actual keybind settings
        if (lowerKey.startsWith("key.")) {
            return new DetectionResult(DetectionType.KEYBIND_PROBE, key, "Keybind probe", 4);
        }
        
        return new DetectionResult(DetectionType.NONE, null, null, 0);
    }
    
    /**
     * Sanitize a string by removing suspicious translation content (BLOCK mode).
     * Used for anvils where we only have the resolved string.
     * 
     * Only clears:
     * 1. Long/specific resolved values (e.g., "English", "Left Button") - NOT single characters
     * 2. Translation key patterns in text (e.g., "language.name", "key.forward")
     * 
     * Does NOT clear normal text or single characters that users could have typed.
     */
    public static String sanitizeText(String text) {
        if (text == null) {
            return "";
        }
        
        String trimmed = text.trim();
        
        // Check if it's a long/specific known resolved value (not single chars)
        if (isKnownResolvedValue(text)) {
            Incognito.LOGGER.debug("[TranslationExploit] Sanitized resolved value: '{}' -> ''", text);
            return "";
        }
        
        // Check if it IS a translation key pattern (the actual exploit string)
        if (TRANSLATION_KEY_PATTERN.matcher(trimmed).matches()) {
            DetectionResult result = analyzeText(trimmed);
            if (result.type != DetectionType.NONE) {
                Incognito.LOGGER.debug("[TranslationExploit] Sanitized translation key: '{}' -> '' ({})", text, result.reason);
                return "";
            }
        }
        
        // Also check for keybind patterns (like "key.forward")
        if (KEYBIND_PATTERN.matcher(trimmed).matches()) {
            Incognito.LOGGER.debug("[TranslationExploit] Sanitized keybind pattern: '{}' -> ''", text);
            return "";
        }
        
        return text;
    }
    
    /**
     * Spoof a string by replacing resolved values with translation keys (SPOOF mode).
     * Used for anvils where we only have the resolved string.
     * 
     * IMPORTANT: For anvils, we can't tell if "W" was typed by user or from a keybind.
     * So we only spoof LONG/SPECIFIC resolved values that are clearly from translation.
     * Single characters are left alone.
     * 
     * @param text The text that may contain resolved translation values
     * @return The spoofed text, or the original if not suspicious
     */
    public static String spoofText(String text) {
        if (text == null) {
            return "";
        }
        
        // Skip short text (single chars, digits) - could be normal user input
        if (text.length() <= 2) {
            return text;
        }
        
        if (KeybindDefaults.isKnownValue(text)) {
            String key = KeybindDefaults.getKeyForValue(text);
            Incognito.LOGGER.debug("[TranslationExploit] Spoofed keybind value: '{}' -> '{}'", text, key);
            return key;
        }
        
        // Check if it's a language value match (all are specific enough)
        if (LANGUAGE_VALUE_TO_KEY.containsKey(text)) {
            String key = LANGUAGE_VALUE_TO_KEY.get(text);
            Incognito.LOGGER.info("[TranslationExploit] Spoofed language value: '{}' -> '{}'", text, key);
            return key;
        }
        
        // Check if it IS a translation key pattern (like "language.name", "key.forward")
        // If so, keep it as-is (it's already the key, not the resolved value)
        String trimmed = text.trim();
        if (TRANSLATION_KEY_PATTERN.matcher(trimmed).matches()) {
            DetectionResult detection = analyzeText(trimmed);
            if (detection.type != DetectionType.NONE) {
                Incognito.LOGGER.info("[TranslationExploit] Keeping translation key: '{}'", text);
                return text;
            }
        }
        
        // Check for keybind pattern (like "key.forward")
        if (KEYBIND_PATTERN.matcher(trimmed).matches()) {
            Incognito.LOGGER.info("[TranslationExploit] Keeping keybind pattern: '{}'", text);
            return text;
        }
        
        // Not suspicious - return original text unchanged
        return text;
    }
    
    /**
     * Check if text looks like a resolved translation value that should be protected.
     * Used for detection in anvil contexts where we only have the resolved string.
     * 
     * IMPORTANT: For anvils, we can't tell if "W" was typed by user or came from a keybind.
     * So we only flag LONG/SPECIFIC resolved values that are unlikely to be user input.
     * 
     * Single characters (W, E, S, D, etc.) are NOT flagged because users could type them.
     */
    public static boolean isKnownResolvedValue(String text) {
        if (text == null || text.isEmpty()) {
            return false;
        }
        
        // Only flag longer/specific values that are clearly from translation resolution
        // NOT single characters that could be normal user input
        
        // Skip single characters and digits - too common in normal text
        if (text.length() <= 2) {
            return false;
        }
        
        if (KeybindDefaults.isKnownValue(text)) {
            return true;
        }
        
        if (LANGUAGE_VALUE_TO_KEY.containsKey(text)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if text contains suspicious content that should trigger protection FOR ANVILS.
     * 
     * For anvils, we're very conservative - only flag:
     * 1. Long/specific resolved values like "English", "Left Button", "Left Shift"
     *    (NOT single characters like "W" which could be user typing)
     * 2. Translation key patterns in the text (e.g., "language.name", "key.forward")
     * 
     * This is different from signs where we have Component access.
     */
    public static boolean containsSuspiciousResolvedValue(String text) {
        if (text == null || text.isEmpty()) {
            return false;
        }
        
        // Check for long/specific resolved values only (not single chars)
        if (isKnownResolvedValue(text)) {
            return true;
        }
        
        // Check if text IS a translation key pattern (e.g., "language.name", "key.forward")
        // This catches the actual exploit strings if they appear literally
        String trimmed = text.trim();
        if (TRANSLATION_KEY_PATTERN.matcher(trimmed).matches()) {
            DetectionResult result = analyzeText(trimmed);
            if (result.type != DetectionType.NONE) {
                return true;
            }
        }
        
        // Check if it's a keybind pattern (e.g., "key.forward")
        if (KEYBIND_PATTERN.matcher(trimmed).matches()) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Sanitize a Component to remove translatable/keybind content
     */
    public static Component sanitizeComponent(Component component) {
        if (component == null) {
            return Component.empty();
        }
        
        if (containsTranslatableContent(component)) {
            return Component.empty();
        }
        
        return component;
    }
    
}
